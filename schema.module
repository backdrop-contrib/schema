<?
// $Id$

// schema_schema: The database schema for schema.module.  Used
// (eventually) to store information about which modules own which
// tables, each module's schema version, etc.  Currently it is really
// only here as a demonstration.
//
function schema_schema() {
  $schema['#version'] = 1;

  $schema['schema_modules'] = array(
    'name' => 'schema_modules',
    'cols' => array(
      'mid' => array('type' => 'int', 'not null' => '1'),
      'name' => array('type' => 'varchar', 'length' => 255, 'not null' => '1'),
      ),
    'keys' => array('PRIMARY' => array('mid')));
  
  $schema['schema_tables'] = array(
    'name' => 'schema_tables',
    'cols' => array(
      'tid' => array('type' => 'int', 'not null' => '1'),
      'name' => array('type' => 'varchar', 'length' => 255, 'not null' => 1),
      'mid' => array('type' => 'int', 'not null' => '1',
        'join-n' => 'schema_modules.mid')),
    'keys' => array(
      'PRIMARY' => array('tid'),
      'mid' => array('mid'),
      ));
  return $schema;
}

// schema_phpprint: Return a pretty ASCII-formatted version of a
// $schema array.  This is nothing more than a specialized variation
// of var_dump and similar functions and is used only as a convenience
// to generate the PHP for existing database tables (to bootstrap
// support for modules that previously used CREATE TABLE explicitly)
// and for debugging.
//
function schema_phpprint($schema) {
  foreach ($schema as $name => $table) {
    if (substr($name, 0, 1) == '#') {
      $out .= "\$schema['$name'] = '$table';\n";
      continue;
    }
    
    $cols = array();
    foreach ($table['cols'] as $colname => $col) {
      $attrs = array();
      foreach (array('type', 'not null', 'default', 'length') as $attr) {
        if (isset($col[$attr])) {
          if (is_string($col[$attr])) {
            $attrs[] = "'$attr' => '$col[$attr]'";
          } else {
            $attrs[] = "'$attr' => $col[$attr]";
          }
          unset($col[$attr]);
        }
      }
      foreach (array_keys($col) as $attr) {
        if (is_string($col[$attr])) {
          $attrs[] = "'$attr' => '$col[$attr]'";
        } else {
          $attrs[] = "'$attr' => $col[$attr]";
        }
      }
      $colstr = "'$colname' => array(".implode(', ', $attrs).")";
      $cols[] = $colstr;
    }
    $keys = array();
    if (is_array($table['keys'])) {
      foreach ($table['keys'] as $keyname => $key) {
        $keystr = "'$keyname' => array('$key[0]'";
        if ($key[1] == 'unique') {
          $keystr .= ", 'unique'";
        }
        $keystr .= ')';
        $keys[] = $keystr;
      }
    }
    $out .= "\$schema['".$name."'] = array(\n    'cols' => array(\n         ";
    $out .= implode(",\n         ", $cols);
    $out .= "),\n";
    if (count($keys) > 0) {
      $out .= "    'keys' => array(\n         ";
      $out .= implode(",\n         ", $keys);
      $out .= "),\n";
    }
    $out .= ");\n";
  }

  return $out;
}

//////////////////////////////////////////////////////////////////////
// Schema API functions
//
// To do:
// 
// schema_add_column
// schema_remove_column
// schema_add_index
// schema_remove_index
// schema_sync_column: Alters a column to match the provided spec,
//   re-creating any indexes if necessary (since dropping a column
//   drops its indexes).
// schema_sync_table: Same as above for all columns and indexes.
// 
//////////////////////////////////////////////////////////////////////

function schema_invoke($op) {
  global $db_type;
  $function = 'schema_'.$db_type.'_'.$op;
  $args = func_get_args();
  array_shift($args);
  return call_user_func_array($function, $args);
}

function schema_create_schema($schema) {
  foreach ($schema as $name => $table) {
    if (substr($name, 0, 1) == '#') {
      continue;
    }
    schema_create_table($table);
  }
}

function schema_drop_schema($schema) {
  foreach ($schema as $name => $table) {
    if (substr($name, 0, 1) == '#') {
      continue;
    }
    schema_drop_table($table);
  }
}
    
function schema_create_table_sql($spec) {
  return schema_invoke('create_table_sql', $spec);
}

function schema_create_table($spec) {
  return db_query(schema_invoke('create_table_sql', $spec));
}

function schema_drop_table($spec) {
  return db_query('DROP TABLE {'.$spec['name'].'}');
}

// schema_compare_schemas: Compare two complete schemas.  $ref is
// considered the reference copy and $inspect is compared against
// it.  If $inspect is NULL, a schema for the currently database is
// generated and used.
function schema_compare_schemas($ref, $inspect = NULL) {
  if (! isset($inspect)) {
    $inspect = schema_invoke('inspect');
  }

  $info = array();
  foreach ($ref as $module => $tables) {
    foreach ($tables as $name => $table) {
      if (substr($name, 0, 1) == '#') {
        continue;
      }
      $status = schema_compare_table($table, $inspect[$name]);
      $info[$status['status']][$module][$name] = $status;
      unset($inspect[$name]);
    }
  }
  foreach ($inspect as $name => $table) {
    $info['extra'][] = $name;
  }
  return $info;
}

// schema_compare_table: Compare a table specification (such as one
// returned by a module's hook_schema) to an inspected table from the
// database.  If $inspect is not provided, its specification is
// inspected.  
//
// Returns 'same', 'missing', or 'different'.
//
function schema_compare_table($ref, $inspect = NULL, &$reasons = array()) {
  if (! isset($inspect)) {
    $inspect = schema_invoke('inspect', $ref['name']);
    $inspect = $inspect[$ref['name']];
  }
  if (! isset($inspect)) {
    return array('status' => 'missing');
  }

  // $reasons could usefully be more verbose...

  $col_keys = array_flip(
    array('type', 'not null', 'length', 'unsigned', 'default'));
  foreach ($ref['cols'] as $colname => $col) {
    $col = array_intersect_key($col, $col_keys);
    if (! isset($inspect['cols'][$colname])) {
      $reasons[] = "$colname: not in database";
      continue;
    }
    $colcmp1 = array_diff_assoc($col, $inspect['cols'][$colname]);
    if (count($colcmp1) != 0) {
      foreach ($colcmp1 as $key => $val) {
          $reasons[] = "column $colname: $key: ref $val != schema ".$inspect['cols'][$colname][$key];
      }
    }
    $colcmp2 = array_diff_assoc($inspect['cols'][$colname], $col);
    if (count($colcmp2) != 0) {
      foreach ($colcmp2 as $key => $val) {
        if (isset($col_keys[$key])) {
          $reasons[] = "$colname: $key: missing in schema";
        }
      }
    }
    unset($inspect['cols'][$colname]);
  }
  foreach ($inspect['cols'] as $colname => $col) {
    $reasons[] = "$colname: unexpected column in database";
  }

  if (is_array($ref['keys'])) {
    foreach ($ref['keys'] as $keyname => $key) {
      if (! isset($inspect['keys'][$keyname])) {
        $reasons[] = "index $keyname: missing";
        continue;
      }
      // $key[0] is column list
      if ($key[0] !== $inspect['keys'][$keyname][0]) {
        $reasons[] = ("index $keyname columns: schema ".print_r($key[0],1).
          ' vs. inspected '.print_r($inspect['keys'][$keyname][0],1));
      }
      // $key[1] is index type: unique or multi.  'multi' is the
      // default in the reference but is required in the inspection.
      if ($key[1] !== $inspect['keys'][$keyname][1] &&
        !(!isset($key[1]) && $inspect['keys'][$keyname][1] == 'multi')) {
        $reasons[] = ("index $keyname number: schema ".print_r($key,1).
          ' vs. inspected '.print_r($inspect['keys'][$keyname][1],1));
      }
      unset($inspect['keys'][$keyname]);
    }
  }
  if (is_array($inspect['keys'])) {
    foreach ($inspect['keys'] as $keyname => $col) {
      // this is not an error, the dba might have added it on purpose
      $notes[] = "index $keyname: unexpected index";
    }
  }

  $status = (count($reasons) ? 'different' : 'same');
  return array('status' => $status, 'reasons' => $reasons,
      'notes' => $notes);
}

// Collect the results of all modules that implement hook_schema.  The
// data structures do not quite lend themselves to the way
// module_invoke_all() treats them.
function schema_invoke_all() {

  // XXX This should be cached when generated but the cache will need
  // to be cleared every time a schema changes (when modules are
  // enabled or disabled, when updates occur, or when a CCK type
  // structure changes).  Until schema_clear_cache() calls are put
  // into the right places, just generate the schema from scratch
  // every time.

  $schema = array();
  foreach (module_implements('schema') as $module) {
    $function = $module.'_schema';
    $mod_schema = $function();
    if (is_array($mod_schema)) {
      $schema[$module] = $mod_schema;
      foreach ($schema[$module] as $name => $table) {
        if (substr($name, 0, 1) == '#') {
          continue;
        }
        $schema[$module][$name]['name'] = $name;
      }
    }
  }

  // Compute and store inverted join information so each table knows
  // which other tables join to it.
  foreach ($schema as $module => $tables) {
    foreach ($tables as $t_name => $table) {
      if (substr($t_name, 0, 1) == '#') {
        continue;
      }
      foreach ($table['cols'] as $c_name => $col) {
        if (isset($col['join'])) {
          list($to_mod, $to_tab, $to_col) = $col['join'];
          $schema[$to_mod][$to_tab]['join-from'][] = array(
            $to_col, $module, $t_name, $c_name, $col['join-type']);
        }
      }
    }
  }

  return $schema;
}

//////////////////////////////////////////////////////////////////////
// Schema administration and UI
//////////////////////////////////////////////////////////////////////

function schema_init() {
  schema_require();
}

function schema_require() {
  static $done = 0;
  if ($done++) { return; }

  // Load all our module 'on behalfs' so they will be available for
  // any module (including this one) that needs them.
  $path = drupal_get_path('module', 'schema') . '/modules';
  $files = drupal_system_listing('schema_.*\.inc$', $path, 'name', 0);
  foreach($files as $file) {
    // The filename format is very specific. It must be schema_MODULENAME.inc
    $module = substr_replace($file->name, '', 0, 7);
    if (module_exists($module)) {
      require_once("./$file->filename");
    }
  }

  // Load the schema database engine for the currently active database.
  global $db_type;
  $engine = (drupal_get_path('module', 'schema').
    '/engines/schema_'.$db_type.'.inc');
  if (is_file($engine)) {
    require_once($engine);
  }
  else {
    drupal_set_message('The Schema module does not support the '.$db_type.
      ' database type ('.$engine.').  Your system will work '.
      'but the Schema module will not to operate.', 'error');
  }
}

function schema_perm() {
  return array('administer schema');
}

function schema_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/build/schema',
      'title' => t('Schema'),
      'description' => t('Manage the database schema for this system.'),
      'callback' => 'schema_report',
      'access' => user_access('administer schema'),
      );

    $items[] = array(
      'path' => 'admin/build/schema/report',
      'title' => t('Report'),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'callback' => 'schema_report',
      'weight' => -10,
      );


    $items[] = array(
      'path' => 'admin/build/schema/inspect',
      'title' => t('Inspect'),
      'type' => MENU_LOCAL_TASK,
      'callback' => 'schema_inspect',
      );

    $items[] = array(
      'path' => 'admin/build/schema/sql',
      'title' => t('SQL'),
      'type' => MENU_LOCAL_TASK,
      'callback' => 'schema_sql',
      );
  }

  return $items;
}

// This function just massages the data returned by
// schema_compare_schemas() into HTML.
function schema_report() {
  $states = array(
    'same' => ('Match'),
    'different' => ('Mismatch'),
    'missing' => ('Missing'),
    'extra' => ('Extra'),
    );
  $descs = array(
    'same' => 'Tables for which the schema and database agree.',
    'different' => 'Tables for which the schema and database are different.',
    'missing' => 'Tables in the schema that are not present in the database.',
    'extra' => 'Tables in the database that are not present in the schema.',
    );

  $generate = schema_invoke_all();
  $info = schema_compare_schemas($generate);
  foreach ($info as $state => $modules) {
    if ($state == 'extra') {
      if (!is_array($data[$state])) {
        $data[$state] = array();
      }
      $data[$state] = array_merge($data[$state], $modules);
      $counts[$state] += count($modules);
      continue;
    }

    foreach ($modules as $module => $tables) {
      $counts[$state] += count($tables);
      switch ($state) {
        case 'same':
        case 'missing':
          $data[$state] .= theme('item_list', array_keys($tables), $module);
          break;

        case 'different':
          $items = array();
          foreach ($tables as $name => $stuff) {
            $items[] = "<h4>$name</h4>".theme('item_list', 
              $tables[$name]['reasons']);
          }
          $form = array();
          $form[$module] = array(
            '#type' => 'fieldset',
            '#title' => t($module),
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
            );
          $form[$module]['content'] = array(
            '#value' => theme('item_list', $items),
            );
          $data[$state] .= drupal_render($form);
          break;
      }
    }
  }
  $data['extra'] = theme('item_list', $data['extra']);

  $form = array();
  $weight = 0;
  foreach ($states as $state => $content) {
    $content = $data[$state];
    $form[$state] = array(
      '#type' => 'fieldset',
      '#title' => t('@state (@count)', 
        array('@state' => $states[$state], '@count' => $counts[$state] ? $counts[$state] : 0)),
      '#description' => t($descs[$state]),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => $weight++,
      );
    $form[$state]['content'] = array(
      '#type' => 'markup',
      '#value' => $content);
  }

  $output .= <<<EOT
<p>This page compares the live database as it currently exists against
the combination of all schema information provided by all enabled modules.</p>
EOT;

  $output .= drupal_render($form);
  return $output;
}

function schema_inspect() {
  $inspect = schema_invoke('inspect');
  $pp = schema_phpprint($inspect);
  $output .= <<<EOT
<p>This page shows the live database schema as it currently
exists on this system.  The data structure is generated dynamically
and includes all tables.  No relationship
information (such as which tables belong to which modules or how the
tables JOIN together) is displayed
because that information is not represented in the database itself.
This page is primarily useful for creating a hook_schema() function
for modules that do not yet have one.</p>
<textarea style="width:100%" rows="30">$pp</textarea>
EOT;

  return $output;
}

function schema_sql() {
  $schema = schema_invoke_all();
  foreach ($schema as $module => $tables) {
    foreach ($tables as $name => $table) {
      if (substr($name, 0, 1) == '#') {
        continue;
      }
      $sql .= schema_create_table_sql($table);
    }
  }
    
  $output = <<<EOT
<p>This page shows the CREATE TABLE statements that the Schema module 
generates for each table defined by a module.</p>
<textarea style="width:100%" rows="30">$sql</textarea>
EOT;

  return $output;
}

//////////////////////////////////////////////////////////////////////
// Schema node stuff
//////////////////////////////////////////////////////////////////////

function schema_nodeapi(&$node, $op, $a3, $a4) {
  switch ($op) {
    case 'load':

      // We're loading a node.  Assemble a LEFT JOIN for every table
      // that joins to node.nid.  This information is available in
      // node's join-from property, assembled by schema_invoke_all().
      $schema = schema_invoke_all();

      $joins = array();
      if (is_array($schema['system']['node']['join-from'])) {
        $join_many = 0;
        foreach ($schema['system']['node']['join-from'] as $join) {
          list($my_col, $to_mod, $to_tab, $to_col, $join_type) = $join;
          
          // Optimization: do not join to tables that declare the node
          // types they relate to and do not list this node type.
          // This saves a join that will produce no results.
          if (isset($schema[$to_mod][$to_tab]['cols'][$to_col]['node-types'])&&
            array_search($node->type, $schema[$to_mod][$to_tab]['cols']
              [$to_col]['node-types']) === FALSE) {
            continue;
          }

          // SELECT each column individually from the joined table so
          // we cn access them by name  below.
          foreach ($schema[$to_mod][$to_tab]['cols'] as $c_name => $col) {
            $sel_as = "${to_tab}_${c_name}";
            $selcols[$to_tab][] = $sel_as;
            $sels[] = "$to_tab.$c_name as $sel_as";
          }

          // LEFT JOIN to each table.  We need to use LEFT JOIN
          // because only a subset of the tables will have any data
          // for this node.
          $joins[] ="LEFT JOIN {$to_tab} $to_tab ON n.$my_col=$to_tab.$to_col";
          $jointypes[$to_tab] = $join_type;
          if ($join_type == 'many') {
            $join_many++;
          }
        }
      }

      // If no one wants this, go home.
      if (count($joins) == 0) {
        break;
      }

      // XXX Implement a multi-column rollup handler.
      if ($join_many > 1) {
        drupal_set_message('Schema: Only one 1-to-many node join is '.
          'currently supported.', 'error');
        break;
      }

      // Execute our rather large assembled query.  Not just for Views anymore!
      $sql = ('SELECT '.implode(",\n\t", $sels)."\nFROM {node} n\n".
        implode("\n\t", $joins)."\nWHERE n.nid=%d");
      //dpm($sql);
      $q = db_query($sql, $node->nid);

      // Each row of the results will have values from one or more
      // tables.  We saved the list of columns selected from each
      // table above.  For each row, if any of the columns from a
      // particular table have are non-NULL, save all of that table's
      // columns for this row.  If all of the columns are NULL, we are
      // seeing LEFT JOIN artifact.
      //
      // Some tables are 1-to-1 joins and some are 1-to-many.  We will
      // get a separate row for each 1-to-many join and the 1-to-1
      // join data will be duplicated each time.  After the first time
      // we get non-NULL data for a 1-to-1 join, stop looking for data
      // from those columns so we do not store duplicate values.
      //
      // Save all the data in $node->schema_data, an array mapping
      // table names to an array of result rows.
      while ($r = db_fetch_array($q)) {
        foreach ($selcols as $table => $cols) {
          $vals = array();
          $got_val = FALSE;
          foreach ($cols as $sel_as) {
            $vals[$sel_as] = $r[$sel_as];
            $got_val = $got_val || !is_null($r[$sel_as]);
          }
          if ($got_val) {
            $schema_data[$table][] = $vals;
            
            if ($jointypes[$table] == 'one') {
              // ignore any repeated data from this table
              unset($selcols[$table]);
            }
          }
        }
      }

      return array('schema_data' => $schema_data);

    case 'view':
      // For easy debugging and demonstration, display the data we
      // loaded in the node body.  This is temporary, of course.
      $node->content['schema_data'] = array(
        '#title' => 'schema_data',
        '#value' => '<p><b>data loaded by schema in one query</b></p><textarea style="width:100%" rows="30">'.print_r($node->schema_data,1).'</textarea>',
        '#weight' => 99);
      
      break;
  }
}

  
?>
