<?
// $Id$

// schema_schema: The database schema for schema.module.  Used
// (eventually) to store information about which modules own which
// tables, each module's schema version, etc.  Currently it is really
// only here as a demonstration.
//
function schema_schema() {
  $schema['#version'] = 1;

  $schema['schema_modules'] = array(
    'name' => 'schema_modules',
    'cols' => array(
      'mid' => array('type' => 'int', 'not null' => '1'),
      'name' => array('type' => 'varchar', 'length' => 255, 'not null' => '1'),
      ),
    'keys' => array('PRIMARY' => array('mid')));
  
  $schema['schema_tables'] = array(
    'name' => 'schema_tables',
    'cols' => array(
      'tid' => array('type' => 'int', 'not null' => '1'),
      'name' => array('type' => 'varchar', 'length' => 255, 'not null' => 1),
      'mid' => array('type' => 'int', 'not null' => '1',
        'join-n' => 'schema_modules.mid')),
    'keys' => array(
      'PRIMARY' => array('tid'),
      'mid' => array('mid'),
      ));
  return $schema;
}

// schema_phpprint: Return a pretty ASCII-formatted version of a
// $schema array.  This is nothing more than a specialized variation
// of var_dump and similar functions and is used only as a convenience
// to generate the PHP for existing database tables (to bootstrap
// support for modules that previously used CREATE TABLE explicitly)
// and for debugging.
//
function schema_phpprint($schema) {
  foreach ($schema as $name => $table) {
    if (substr($name, 0, 1) == '#') {
      $out .= "\$schema['$name'] = '$table';\n";
      continue;
    }
    
    $cols = array();
    foreach ($table['cols'] as $colname => $col) {
      $attrs = array();
      foreach (array('type', 'not null', 'default', 'length') as $attr) {
        if (isset($col[$attr])) {
          if (is_string($col[$attr])) {
            $attrs[] = "'$attr' => '$col[$attr]'";
          } else {
            $attrs[] = "'$attr' => $col[$attr]";
          }
          unset($col[$attr]);
        }
      }
      foreach (array_keys($col) as $attr) {
        if (is_string($col[$attr])) {
          $attrs[] = "'$attr' => '$col[$attr]'";
        } else {
          $attrs[] = "'$attr' => $col[$attr]";
        }
      }
      $colstr = "'$colname' => array(".implode(', ', $attrs).")";
      $cols[] = $colstr;
    }
    $keys = array();
    if (is_array($table['keys'])) {
      foreach ($table['keys'] as $keyname => $key) {
        $keystr = "'$keyname' => array('$key[0]'";
        if ($key[1] == 'unique') {
          $keystr .= ", 'unique'";
        }
        $keystr .= ')';
        $keys[] = $keystr;
      }
    }
    $out .= "\$schema['".$name."'] = array(\n    'cols' => array(\n         ";
    $out .= implode(",\n         ", $cols);
    $out .= "),\n";
    if (count($keys) > 0) {
      $out .= "    'keys' => array(\n         ";
      $out .= implode(",\n         ", $keys);
      $out .= "),\n";
    }
    $out .= ");\n";
  }

  return $out;
}

//////////////////////////////////////////////////////////////////////
// Schema API functions
//
// To do:
// 
// schema_add_column
// schema_remove_column
// schema_add_index
// schema_remove_index
// schema_sync_column: Alters a column to match the provided spec,
//   re-creating any indexes if necessary (since dropping a column
//   drops its indexes).
// schema_sync_table: Same as above for all columns and indexes.
// 
//////////////////////////////////////////////////////////////////////

function schema_invoke($op) {
  global $db_type;
  $function = 'schema_'.$db_type.'_'.$op;
  $args = func_get_args();
  array_shift($args);
  return call_user_func_array($function, $args);
}

function schema_create_schema($schema) {
  foreach ($schema as $name => $table) {
    if (substr($name, 0, 1) == '#') {
      continue;
    }
    schema_create_table($table);
  }
}

function schema_drop_schema($schema) {
  foreach ($schema as $name => $table) {
    if (substr($name, 0, 1) == '#') {
      continue;
    }
    schema_drop_table($table);
  }
}
    
function schema_create_table_sql($spec) {
  return schema_invoke('create_table_sql', $spec);
}

function schema_create_table($spec) {
  return db_query(schema_invoke('create_table_sql', $spec));
}

function schema_drop_table($spec) {
  return db_query('DROP TABLE {'.$spec['name'].'}');
}

// schema_compare_schemas: Compare two complete schemas.  $ref is
// considered the reference copy and $inspect is compared against
// it.  If $inspect is NULL, a schema for the currently database is
// generated and used.
function schema_compare_schemas($ref, $inspect = NULL) {
  if (! isset($inspect)) {
    $inspect = schema_invoke('inspect');
  }

  $info = array();
  foreach ($ref as $module => $tables) {
    foreach ($tables as $name => $table) {
      if (substr($name, 0, 1) == '#') {
        continue;
      }
      $status = schema_compare_table($table, $inspect[$name]);
      $info[$status['status']][$module][$name] = $status;
      unset($inspect[$name]);
    }
  }
  foreach ($inspect as $name => $table) {
    $info['extra'][] = $name;
  }
  return $info;
}

// schema_compare_table: Compare a table specification (such as one
// returned by a module's hook_schema) to an inspected table from the
// database.  If $inspect is not provided, its specification is
// inspected.  
//
// Returns 'same', 'missing', or 'different'.
//
function schema_compare_table($ref, $inspect = NULL, &$reasons = array()) {
  if (! isset($inspect)) {
    $inspect = schema_invoke('inspect', $ref['name']);
    $inspect = $inspect[$ref['name']];
  }
  if (! isset($inspect)) {
    return array('status' => 'missing');
  }

  // $reasons could usefully be more verbose...

  $col_keys = array_flip(
    array('type', 'not null', 'length', 'unsigned', 'default'));
  foreach ($ref['cols'] as $colname => $col) {
    $col = array_intersect_key($col, $col_keys);
    if (! isset($inspect['cols'][$colname])) {
      $reasons[] = "$colname: not in database";
      continue;
    }
    $colcmp1 = array_diff_assoc($col, $inspect['cols'][$colname]);
    if (count($colcmp1) != 0) {
      foreach ($colcmp1 as $key => $val) {
          $reasons[] = "column $colname: $key: ref $val != schema ".$inspect['cols'][$colname][$key];
      }
    }
    $colcmp2 = array_diff_assoc($inspect['cols'][$colname], $col);
    if (count($colcmp2) != 0) {
      foreach ($colcmp2 as $key => $val) {
        if (isset($col_keys[$key])) {
          $reasons[] = "$colname: $key: missing in schema";
        }
      }
    }
    unset($inspect['cols'][$colname]);
  }
  foreach ($inspect['cols'] as $colname => $col) {
    $reasons[] = "$colname: unexpected column in database";
  }

  if (is_array($ref['keys'])) {
    foreach ($ref['keys'] as $keyname => $key) {
      if (! isset($inspect['keys'][$keyname])) {
        $reasons[] = "index $keyname: missing";
        continue;
      }
      // $key[0] is column list
      if ($key[0] !== $inspect['keys'][$keyname][0]) {
        $reasons[] = ("index $keyname columns: schema ".print_r($key[0],1).
          ' vs. inspected '.print_r($inspect['keys'][$keyname][0],1));
      }
      // $key[1] is index type: unique or multi.  'multi' is the
      // default in the reference but is required in the inspection.
      if ($key[1] !== $inspect['keys'][$keyname][1] &&
        !(!isset($key[1]) && $inspect['keys'][$keyname][1] == 'multi')) {
        $reasons[] = ("index $keyname number: schema ".print_r($key,1).
          ' vs. inspected '.print_r($inspect['keys'][$keyname][1],1));
      }
      unset($inspect['keys'][$keyname]);
    }
  }
  if (is_array($inspect['keys'])) {
    foreach ($inspect['keys'] as $keyname => $col) {
      // this is not an error, the dba might have added it on purpose
      $notes[] = "index $keyname: unexpected index";
    }
  }

  $status = (count($reasons) ? 'different' : 'same');
  return array('status' => $status, 'reasons' => $reasons,
      'notes' => $notes);
}

// Collect the results of all modules that implement hook_schema.  The
// data structures do not quite lend themselves to the way
// module_invoke_all() treats them.
function schema_invoke_all() {

  // XXX This should be cached when generated but the cache will need
  // to be cleared every time a schema changes (when modules are
  // enabled or disabled, when updates occur, or when a CCK type
  // structure changes).  Until schema_clear_cache() calls are put
  // into the right places, just generate the schema from scratch
  // every time.

  $schema = array();
  foreach (module_implements('schema') as $module) {
    $function = $module.'_schema';
    $mod_schema = $function();
    if (is_array($mod_schema)) {
      $schema[$module] = $mod_schema;
      foreach ($schema[$module] as $name => $table) {
        if (substr($name, 0, 1) == '#') {
          continue;
        }
        $schema[$module][$name]['name'] = $name;
      }
    }
  }

  // XXX Drupal 5's primary key for node is (nid,vid) but I
  // (currently) think that is a mistake.
  $schema['system']['node']['keys']['PRIMARY'] = array('nid');

  // Compute and store inverted join information so each table knows
  // which other tables join to it.
  foreach ($schema as $module => $tables) {
    foreach ($tables as $t_name => $table) {
      if (substr($t_name, 0, 1) == '#') {
        continue;
      }
      foreach ($table['cols'] as $c_name => $col) {
        if (isset($col['join'])) {
          list($to_mod, $to_tab, $to_col) = $col['join'];
          $schema[$to_mod][$to_tab]['join-from'][] = array(
            $to_col, $module, $t_name, $c_name, $col['join-type']);
        }
      }
    }
  }

  // Generate the SQL query for each table.
  foreach ($schema as $module => $tables) {
    foreach ($tables as $t_name => $table) {
      if (substr($t_name, 0, 1) == '#') {
        continue;
      }
      _schema_generate_table($schema, $module, $t_name);
    }
  }

  $node_types = node_get_types();
  foreach ($node_types as $type) {
    _schema_generate_table($schema, 'system', 'node', $type->type);
  }

  return $schema;
}

// Generate the SELECT query and associated data to retrieve a
// complete entity from $module's table $t_name.
//
// If $o_type is provided (e.g. "story" if $module is "node")
// eliminate joins to tables that specify which $module types they
// join to and do not include $o_type in the list.  This eliminates
// joins that will never produce any results.  It is currently only
// used for node.
function _schema_generate_table(&$schema, $module, $t_name, $o_type = NULL) {
  $table = $schema[$module][$t_name];

  // We can't build a WHERE clause for a table without a primary key.
  if (!isset($table['keys']['PRIMARY'])) {
    return;
  }
  // SELECT each column individually from the primary table so
  // we can access it by name.
  foreach ($table['cols'] as $c_name => $col) {
    $sel_as = "${t_name}_${c_name}";
    $selcols[$t_name][] = $sel_as;
    $sels[] = "$t_name.$c_name as $sel_as";
  }
  // XXX my data structure for primary keys is not good
  $pcols = explode(', ', $table['keys']['PRIMARY'][0]);
  foreach ($pcols as $pcol) {
    $primarys[$t_name][] = "${t_name}_${pcol}";
    switch ($table['cols'][$pcol]['type']) {
    case 'int': 
    case 'mediumint':
    case 'tinyint':
    case 'bigint':
    case 'float':
      $wheres[] = "${t_name}.${pcol}=%d";
      break;
    default:
      $wheres[] = "${t_name}.{$pcol}='%s'";
      break;
    }
  }

  $joins = array();
  if (!is_array($schema[$module][$t_name]['join-from'])) {
    $schema[$module][$t_name]['join-from'] = array();
  }

  $join_many = 0;
  foreach ($schema[$module][$t_name]['join-from'] as $join) {
    list($my_col, $to_mod, $to_tab, $to_col, $join_type) = $join;
    $table = $schema[$to_mod][$to_tab];

    if (isset($o_type) && is_array($table['cols'][$to_col][$t_name.'-types'])&&
	array_search($o_type, $table['cols'][$to_col][$t_name.'-types'])
	=== FALSE) {
      continue;
    }
    
    // SELECT each column individually from the joined table so
    // we can access it by name.
    foreach ($table['cols'] as $c_name => $col) {
      $sel_as = "${to_tab}_${c_name}";
      $selcols[$to_tab][] = $sel_as;
      $sels[] = "$to_tab.$c_name as $sel_as";
    }

    if (isset($table['keys']['PRIMARY'])) {
      // XXX my data structure for primary keys is not good
      $pcols = explode(', ', $table['keys']['PRIMARY'][0]);
      foreach ($pcols as $pcol) {
        $primarys[$to_tab][] = "${to_tab}_${pcol}";
      }
    } else {
      drupal_set_message('Schema: joins require a primary key', 'error');
      break;
    }

    // LEFT JOIN to each table.  We need to use LEFT JOIN
    // because only a subset of the tables will have any data
    // for this node.
    $joins[] ="LEFT JOIN {$to_tab} $to_tab ON $t_name.$my_col=$to_tab.$to_col";
    $jointypes[$to_tab] = $join_type;
    if ($join_type == 'many') {
      $join_many++;
    }
  }

  // Execute our rather large assembled query.  Not just for Views anymore!
  $sql = ('SELECT '.implode(",\n\t", $sels)."\nFROM {$t_name} $t_name\n".
	  implode("\n\t", $joins)."\nWHERE ".
	  implode(' AND ', $wheres));
  //dpm($sql);

  if (isset($o_type)) {
    $schema[$module][$t_name]['query-'.$o_type] = $sql;
    $schema[$module][$t_name]['selcols-'.$o_type] = $selcols;
    $schema[$module][$t_name]['primarys-'.$o_type] = $primarys;
  } else {
    $schema[$module][$t_name]['query'] = $sql;
    $schema[$module][$t_name]['selcols'] = $selcols;
    $schema[$module][$t_name]['primarys'] = $primarys;
  }
  $schema[$module][$t_name]['jointypes'] = $jointypes;
}

//////////////////////////////////////////////////////////////////////
// Schema administration and UI
//////////////////////////////////////////////////////////////////////

function schema_init() {
  schema_require();
}

function schema_require() {
  static $done = 0;
  if ($done++) { return; }

  // Load all our module 'on behalfs' so they will be available for
  // any module (including this one) that needs them.
  $path = drupal_get_path('module', 'schema') . '/modules';
  $files = drupal_system_listing('schema_.*\.inc$', $path, 'name', 0);
  foreach($files as $file) {
    // The filename format is very specific. It must be schema_MODULENAME.inc
    $module = substr_replace($file->name, '', 0, 7);
    if (module_exists($module)) {
      require_once("./$file->filename");
    }
  }

  // Load the schema database engine for the currently active database.
  global $db_type;
  $engine = (drupal_get_path('module', 'schema').
    '/engines/schema_'.$db_type.'.inc');
  if (is_file($engine)) {
    require_once($engine);
  }
  else {
    drupal_set_message('The Schema module does not support the '.$db_type.
      ' database type ('.$engine.').  Your system will work '.
      'but the Schema module will not to operate.', 'error');
  }
}

function schema_perm() {
  return array('administer schema');
}

function schema_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/build/schema',
      'title' => t('Schema'),
      'description' => t('Manage the database schema for this system.'),
      'callback' => 'schema_report',
      'access' => user_access('administer schema'),
      );

    $items[] = array(
      'path' => 'admin/build/schema/report',
      'title' => t('Report'),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'callback' => 'schema_report',
      'weight' => -10,
      );


    $items[] = array(
      'path' => 'admin/build/schema/inspect',
      'title' => t('Inspect'),
      'type' => MENU_LOCAL_TASK,
      'callback' => 'schema_inspect',
      );

    $items[] = array(
      'path' => 'admin/build/schema/sql',
      'title' => t('SQL'),
      'type' => MENU_LOCAL_TASK,
      'callback' => 'schema_sql',
      );

    $items[] = array(
      'path' => 'admin/build/schema/show',
      'title' => t('Show'),
      'type' => MENU_LOCAL_TASK,
      'callback' => 'schema_show',
      );
  }

  return $items;
}

// This function just massages the data returned by
// schema_compare_schemas() into HTML.
function schema_report() {
  $states = array(
    'same' => ('Match'),
    'different' => ('Mismatch'),
    'missing' => ('Missing'),
    'extra' => ('Extra'),
    );
  $descs = array(
    'same' => 'Tables for which the schema and database agree.',
    'different' => 'Tables for which the schema and database are different.',
    'missing' => 'Tables in the schema that are not present in the database.',
    'extra' => 'Tables in the database that are not present in the schema.',
    );

  $generate = schema_invoke_all();
  $info = schema_compare_schemas($generate);
  foreach ($info as $state => $modules) {
    if ($state == 'extra') {
      if (!is_array($data[$state])) {
        $data[$state] = array();
      }
      $data[$state] = array_merge($data[$state], $modules);
      $counts[$state] += count($modules);
      continue;
    }

    foreach ($modules as $module => $tables) {
      $counts[$state] += count($tables);
      switch ($state) {
        case 'same':
        case 'missing':
          $data[$state] .= theme('item_list', array_keys($tables), $module);
          break;

        case 'different':
          $items = array();
          foreach ($tables as $name => $stuff) {
            $items[] = "<h4>$name</h4>".theme('item_list', 
              $tables[$name]['reasons']);
          }
          $form = array();
          $form[$module] = array(
            '#type' => 'fieldset',
            '#title' => t($module),
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
            );
          $form[$module]['content'] = array(
            '#value' => theme('item_list', $items),
            );
          $data[$state] .= drupal_render($form);
          break;
      }
    }
  }
  $data['extra'] = theme('item_list', $data['extra']);

  $form = array();
  $weight = 0;
  foreach ($states as $state => $content) {
    $content = $data[$state];
    $form[$state] = array(
      '#type' => 'fieldset',
      '#title' => t('@state (@count)', 
        array('@state' => $states[$state], '@count' => $counts[$state] ? $counts[$state] : 0)),
      '#description' => t($descs[$state]),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => $weight++,
      );
    $form[$state]['content'] = array(
      '#type' => 'markup',
      '#value' => $content);
  }

  $output .= <<<EOT
<p>This page compares the live database as it currently exists against
the combination of all schema information provided by all enabled modules.</p>
EOT;

  $output .= drupal_render($form);
  return $output;
}

function schema_inspect() {
  $inspect = schema_invoke('inspect');
  $pp = schema_phpprint($inspect);
  $output .= <<<EOT
<p>This page shows the live database schema as it currently
exists on this system.  The data structure is generated dynamically
and includes all tables.  No relationship
information (such as which tables belong to which modules or how the
tables JOIN together) is displayed
because that information is not represented in the database itself.
This page is primarily useful for creating a hook_schema() function
for modules that do not yet have one.</p>
<textarea style="width:100%" rows="30">$pp</textarea>
EOT;

  return $output;
}

function schema_sql() {
  $schema = schema_invoke_all();
  foreach ($schema as $module => $tables) {
    foreach ($tables as $name => $table) {
      if (substr($name, 0, 1) == '#') {
        continue;
      }
      $sql .= schema_create_table_sql($table);
    }
  }
    
  $output = <<<EOT
<p>This page shows the CREATE TABLE statements that the Schema module 
generates for each table defined by a module.</p>
<textarea style="width:100%" rows="30">$sql</textarea>
EOT;

  return $output;
}

function schema_show() {
  $schema = schema_invoke_all();
  $show = print_r($schema,1);
    
  $output = <<<EOT
<textarea style="width:100%" rows="30">$show</textarea>
EOT;

  return $output;
}

//////////////////////////////////////////////////////////////////////
// Schema node stuff
//////////////////////////////////////////////////////////////////////

function schema_nodeapi(&$node, $op, $a3, $a4) {
  switch ($op) {
    case 'load':
      if (! isset($node->schema_data)) {
        return schema_node_load($node->nid, $node->type, $node);
      }
      break;

    case 'view':
      // For easy debugging and demonstration, display the data we
      // loaded in the node body.  This is temporary, of course.
      $node->content['schema_data'] = array(
        '#title' => 'schema_data',
        '#value' => '<p><b>data loaded by schema in one query</b></p><textarea style="width:100%" rows="30">'.print_r($node->schema_data,1).'</textarea>',
        '#weight' => 99);
      
      break;
  }
}

function schema_node_load($nid, $ntype = NULL, $node = NULL) {
  $schema = schema_invoke_all();

  if (isset($ntype) && 
    isset($schema['system']['node']['query-'.$ntype])) {
    $sql = $schema['system']['node']['query-'.$ntype];
    $selcols = $schema['system']['node']['selcols-'.$ntype];
    $primarys = $schema['system']['node']['primarys-'.$ntype];
  } else {
    $sql = $schema['system']['node']['query'];
    $selcols = $schema['system']['node']['selcols'];
    $primarys = $schema['system']['node']['primarys'];
  }
  $jointypes = $schema['system']['node']['jointypes'];

  //dpm($sql);
  $q = db_query($sql, $nid);

  // Each row of the results will have values from one or more
  // tables.  We saved the list of columns selected from each
  // table above.  For each row, if any of the columns from a
  // particular table are non-NULL, save all of that table's
  // columns for this row.  If all of the columns are NULL, we are
  // seeing LEFT JOIN artifact, so we skip it.
  //
  // The nature of this query is that we get a lot of duplicated
  // data and we have to be sure to ignore all but one copy of
  // each unique result.  For one-joins, it is easy: after we get
  // results for that table we just stop looking for them.  For
  // many-joins, we keep track of the primary keys we've seen from
  // that table and only save a row's data if we haven't seen that
  // primary key yet (by definition, primary keys are unique).
  //
  // Save all the data in $node->schema_data, an array mapping
  // table names to an array of result rows.
  while ($r = db_fetch_array($q)) {
    foreach ($selcols as $table => $cols) {
      $vals = array();
      $got_val = FALSE;
      foreach ($cols as $sel_as) {
        $vals[$sel_as] = $r[$sel_as];
        $got_val = $got_val || !is_null($r[$sel_as]);
      }
      if ($got_val) {
        $keys = $primarys[$table];
        $keyvals = implode('::', array_intersect_key($vals, array_flip($primarys[$table])));
        if (isset($schema_data[$table][$keyvals])) {
          continue;
        }
        $tlen = strlen($table)+1;
        foreach ($vals as $key=>$val) {
          $schema_data[$table][$keyvals][substr($key, $tlen)] = $val;
        }
            
        if ($jointypes[$table] == 'one') {
          // ignore any repeated data from this table
          unset($selcols[$table]);
        }
      }
    }
  }

  // If we're being called by node_load, assemble the node object it
  // expects.  XXX This is a kludge.  users and node both define column
  // 'status', but we want node's, so we list userse first.  This is
  // just a temporary hack anyway; if node_load() wants to use Schema
  // it should just use schema_data directly or assemble the fields of
  // the $node object itself.
  if (is_null($node)) {
    $node = array_merge(
      $schema_data['users'][$schema_data['node'][$nid]['uid']],
      $schema_data['node_revisions'][$schema_data['node'][$nid]['vid']],
      $schema_data['node'][$nid]
      );
    $node = (object) $node;
  }

  $node->schema_data = $schema_data;
  return $node;
}
  
?>
