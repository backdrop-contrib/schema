<?
// $Id$

global $schema_engines;

// schema_phpprint: Return a pretty ASCII-formatted version of a
// $schema array.  This is nothing more than a specialized variation
// of var_dump and similar functions and is used only as a convenience
// to generate the PHP for existing database tables (to bootstrap
// support for modules that previously used CREATE TABLE explicitly)
// and for debugging.
//
function schema_phpprint($schema) {
  $out = '';
  foreach ($schema as $name => $table) {
    $out .= schema_phpprint_table($name, $table);
  }
  return $out;
}

function schema_phpprint_table($name, $table) {
    $cols = array();
    foreach ($table['fields'] as $colname => $col) {
      $cols[] = "'$colname' => ".schema_phpprint_column($col);
    }
    $unique = $index = array();
    if (isset($table['unique keys'])) {
      foreach ($table['unique keys'] as $keyname => $key) {
        $unique[] = "'$keyname' => ".schema_phpprint_key($key);
      }
    }
    if (isset($table['indexes'])) {
      foreach ($table['indexes'] as $keyname => $key) {
        $index[] = "'$keyname' => ".schema_phpprint_key($key);
      }
    }
    $out = '';
    $out .= "\$schema['".$name."'] = array(\n    'fields' => array(\n         ";
    $out .= implode(",\n         ", $cols);
    $out .= "),\n";
    if (isset($table['primary key'])) {
      $out .= "    'primary key' => array('".implode("', '", $table['primary key'])."'),\n";
    }
    if (count($unique) > 0) {
      $out .= "    'unique keys' => array(\n         ";
      $out .= implode(",\n         ", $unique);
      $out .= "),\n";
    }
    if (count($index) > 0) {
      $out .= "    'indexes' => array(\n         ";
      $out .= implode(",\n         ", $index);
      $out .= "),\n";
    }
    $out .= ");\n";
    return $out;
}

function schema_phpprint_column($col) {
  $attrs = array();
  if ($col['type'] == 'varchar' || $col['size'] == 'normal') {
    unset($col['size']);
  }
  foreach (array('type', 'unsigned', 'size', 'length', 'not null', 'default') as $attr) {
    if (isset($col[$attr])) {
      if (is_string($col[$attr])) {
        $attrs[] = "'$attr' => '$col[$attr]'";
      } else {
        $attrs[] = "'$attr' => $col[$attr]";
      }
      unset($col[$attr]);
    }
  }
  foreach (array_keys($col) as $attr) {
    if (is_string($col[$attr])) {
      $attrs[] = "'$attr' => '$col[$attr]'";
    } else {
      $attrs[] = "'$attr' => $col[$attr]";
    }
  }
  return "array(".implode(', ', $attrs).")";
}

function schema_phpprint_key($keys) {
  $ret = array();
  foreach ($keys as $key) {
    if (is_array($key)) {
      $ret[] = "array('$key[0]', $key[1])";
    } else {
      $ret[] = "'$key'";
    }
  }
  return "array(".implode(", ", $ret).")";
}

//////////////////////////////////////////////////////////////////////
// Schema API functions
//
// To do:
// 
// schema_add_column
// schema_remove_column
// schema_add_index
// schema_remove_index
// schema_sync_column: Alters a column to match the provided spec,
//   re-creating any indexes if necessary (since dropping a column
//   drops its indexes).
// schema_sync_table: Same as above for all columns and indexes.
// 
//////////////////////////////////////////////////////////////////////

function schema_invoke($op) {
  global $db_type;
  $function = 'schema_'.$db_type.'_'.$op;
  $args = func_get_args();
  array_shift($args);
  return call_user_func_array($function, $args);
}

function schema_engine_invoke($engine, $op) {
  global $db_type;
  if (!isset($engine)) {
    $engine = $db_type;
  }
  $function = 'schema_'.$engine.'_'.$op;
  $args = func_get_args();
  array_shift($args);
  return call_user_func_array($function, $args);
}

// Convert a column's Schema type into an engine-specific data type.
function schema_engine_type($col, $engine = NULL) {
  $map = schema_engine_invoke($engine, 'engine_type_map');
  $size = (isset($col['size']) ? $col['size'] : 'normal');
  $type = $col['type'].':'.$size;
  if (isset($map[$type])) {
    return $map[$type];
  } else {
    drupal_set_message(t('No %engine type for Schema type %type.',
                         array('%engine' => $engine, '%type' => $type)),
      'error');
    return $col['type'];
  }
}

// Convert an engine-specific data type into a Schema type.
function schema_schema_type($type, $engine = NULL) {
  $map = schema_engine_invoke($engine, 'schema_type_map');
  if (isset($map[$type])) {
    return explode(':', $map[$type]);
  } else {
    drupal_set_message(t('No Schema type for %engine type %type.',
                         array('%engine' => $engine, '%type' => $type)),
      'error');
    return array($type, 'normal');
  }
}

// schema_compare_schemas: Compare two complete schemas.  $ref is
// considered the reference copy and $inspect is compared against
// it.  If $inspect is NULL, a schema for the currently database is
// generated and used.
function schema_compare_schemas($ref, $inspect = NULL) {
  if (! isset($inspect)) {
    $inspect = schema_invoke('inspect');
  }
  
  $info = array();
  foreach ($ref as $name => $table) {
    $module = $table['module'];
    if (!isset($inspect[$name])) {
      $info['missing'][$module][$name] = array('status' => 'missing');
    } else {
      $status = schema_compare_table($table, $inspect[$name]);
      $info[$status['status']][$module][$name] = $status;
      unset($inspect[$name]);
    }
  }

  foreach ($inspect as $name => $table) {
    $info['extra'][] = $name;
  }
  return $info;
}

// schema_compare_table: Compare a reference specification (such as
// one returned by a module's hook_schema) to an inspected specification from
// the database.  If $inspect is not provided, the database is inspected.
//
function schema_compare_table($ref, $inspect = NULL, &$reasons = array()) {
  global $db_type;
  $_db_type = $db_type;
  if ($_db_type == 'mysqli') {
    $_db_type = 'mysql';
  }

  if (! isset($inspect)) {
    $inspect = schema_invoke('inspect', $ref['name']);
    $inspect = $inspect[$ref['name']];
  }
  if (! isset($inspect)) {
    return array('status' => 'missing');
  }

  $reasons = $notes = array();
  $col_keys = array_flip(
    array('type', 'size', 'not null', 'length', 'unsigned', 'default'));
  foreach ($ref['fields'] as $colname => $col) {

    // Many Schema types can map to the same engine type (e.g. in
    // PostgresSQL, text:{small,medium,big} are all just text).  When
    // we inspect the database, we see the common type, but the
    // reference we are comparing against can have a specific type.
    // We therefore run the reference's specific type through the
    // type conversion cycle to get its common type for comparison.
    //
    // Sadly, we need a special-case hack for 'serial'.
    $serial = ($col['type'] == 'serial' ? TRUE : FALSE);
    $dbtype = schema_engine_type($col);
    list($col['type'], $col['size']) = schema_schema_type($dbtype);
    if ($serial) {
      $col['type'] = 'serial';
    }

    // If an engine-specific type is specified, use it.  XXX $inspect
    // will contain the schema type for the engine type, if one
    // exists, whereas dbtype_type contains the engine type.
    if (isset($col[$_db_type .'_type'])) {
      $col['type'] = $col[$_db_type .'_type'];
    }

    $col = array_intersect_key($col, $col_keys);
    if (! isset($inspect['fields'][$colname])) {
      $reasons[] = "$colname: not in database";
      continue;
    }
    // XXX These should be unified so one reason contains all
    // mismatches between the columns.
    $colcmp1 = array_diff_assoc($col, $inspect['fields'][$colname]);
    if (count($colcmp1) != 0) {
      foreach ($colcmp1 as $key => $val) {
        $reasons[] = ("column $colname:<br/>declared: ".
          schema_phpprint_column($col).'<br/>actual: '.
          schema_phpprint_column($inspect['fields'][$colname]));
      }
    }
    $colcmp2 = array_diff_assoc($inspect['fields'][$colname], $col);
    if (count($colcmp2) != 0) {
      foreach ($colcmp2 as $key => $val) {
        if (isset($col_keys[$key]) && !isset($colcmp1[$key])) {
          $reasons[] = ("column $colname:<br/>declared: ".
            schema_phpprint_column($col).'<br/>actual: '.
            schema_phpprint_column($inspect['fields'][$colname]));
        }
      }
    }
    unset($inspect['fields'][$colname]);
  }
  foreach ($inspect['fields'] as $colname => $col) {
    $reasons[] = "$colname: unexpected column in database";
  }

  if (isset($ref['primary key'])) {
    if (! isset($inspect['primary key'])) {
      $reasons[] = "primary key: missing in database";
    }
    else if ($ref['primary key'] !== $inspect['primary key']) {
      $reasons[] = ("primary key:<br />declared: ".
        schema_phpprint_key($ref['primary key']).'<br />actual: '.
        schema_phpprint_key($inspect['primary key']));
    }
  } 
  else if (isset($inspect['primary key'])) {
    $reasons[] = "primary key: missing in schema";
  }

  foreach (array('unique keys', 'indexes') as $type) {
    if (isset($ref[$type])) {
      foreach ($ref[$type] as $keyname => $key) {
        if (! isset($inspect[$type][$keyname])) {
          $reasons[] = "$type $keyname: missing in database";
          continue;
        }
        // $key is column list
        if ($key !== $inspect[$type][$keyname]) {
          $reasons[] = ("$type $keyname:<br />declared: ".
            schema_phpprint_key($key).'<br />actual: '.
            schema_phpprint_key($inspect[$type][$keyname]));
        }
        unset($inspect[$type][$keyname]);
      }
    }
    if (isset($inspect[$type])) {
      foreach ($inspect[$type] as $keyname => $col) {
        // this is not an error, the dba might have added it on purpose
        $notes[] = "$type $keyname: unexpected (not an error)";
      }
    }
  }

  $status = (count($reasons) ? 'different' : 'same');
  return array('status' => $status, 'reasons' => $reasons,
    'notes' => $notes);
}

//////////////////////////////////////////////////////////////////////
// Schema administration and UI
//////////////////////////////////////////////////////////////////////

function schema_init() {
  schema_require();
}

function schema_require() {
  static $done = 0;
  if ($done++) { return; }

  // Load all our module 'on behalfs' so they will be available for
  // any module (including this one) that needs them.
  $path = drupal_get_path('module', 'schema');
  $files = drupal_system_listing('schema_.*\.inc$', $path.'/modules','name',0);
  foreach($files as $file) {
    // The filename format is very specific. It must be schema_MODULENAME.inc
    $module = substr_replace($file->name, '', 0, 7);
    require_once("./$file->filename");
  }

  global $db_type, $schema_engines;

  if (!isset($db_type)) {
    return;
  }

  $schema_engines = array();
  if (0) {
    // Load the schema database engine for the currently active database.
    $engine = (drupal_get_path('module', 'schema').
      '/engines/schema_'.$db_type.'.inc');
    if (is_file($engine)) {
      require_once($engine);
      $schema_engines[] = $db_type;
    }
  } else {
    // Load all Schema database engines.
    $files =drupal_system_listing('schema_.*\.inc$',$path.'/engines','name',0);
    foreach($files as $file) {
      require_once("./$file->filename");
      $schema_engines[] = substr($file->filename, strlen($path)+16, -4);
    }
  }
      
  if (array_search($db_type, $schema_engines) === FALSE) {
    drupal_set_message('The Schema module does not support the "'.$db_type.
      '" database type.', 'error');
  }
}

function schema_perm() {
  return array('administer schema');
}

function schema_menu() {
  $items['admin/build/schema'] = array(
    'title' => 'Schema',
    'description' => 'Manage the database schema for this system.',
    'page callback' => 'schema_report',
    'access arguments' => array('administer schema'),
    );

  $items['admin/build/schema/report'] = array(
    'title' => 'Compare',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'page callback' => 'schema_report',
    'weight' => -10,
    );


  $items['admin/build/schema/inspect'] = array(
    'title' => 'Inspect',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'schema_inspect',
    );

  $items['admin/build/schema/sql'] = array(
    'title' => 'SQL',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'schema_sql',
    );

  // This can't work unless we rename the functions in database.*.inc.
  global $db_type, $schema_engines;
  if (FALSE && isset($schema_engines) && is_array($schema_engines)) {
    foreach ($schema_engines as $engine) {
      $items['admin/build/schema/sql/'.$engine] = array(
        'title' => t($engine),
        'type' => ($engine == $db_type ? MENU_DEFAULT_LOCAL_TASK : 
          MENU_LOCAL_TASK),
        'page callback' => 'schema_sql',
        'callback arguments' => $engine,
        );
    }
  }

  $items['admin/build/schema/show'] = array(
    'title' => 'Show',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'schema_show',
    'weight' => 10,
    );

  return $items;
}

// This function just massages the data returned by
// schema_compare_schemas() into HTML.
function schema_report() {
  $states = array(
    'same' => ('Match'),
    'different' => ('Mismatch'),
    'missing' => ('Missing'),
    'extra' => ('Extra'),
    );
  $descs = array(
    'same' => 'Tables for which the schema and database agree.',
    'different' => 'Tables for which the schema and database are different.',
    'missing' => 'Tables in the schema that are not present in the database.',
    'extra' => 'Tables in the database that are not present in the schema.  This probably indicates modules that do not use the Schema API.',
    );

  $schema = drupal_get_schema();
  $info = schema_compare_schemas($schema);

  foreach ($info as $state => $modules) {
    $counts[$state] = 0;
    $data[$state] = ($state == 'extra' ? array() : '');

    if ($state == 'extra') {
      $data[$state] = array_merge($data[$state], $modules);
      $counts[$state] += count($modules);
      continue;
    }
    else if ($state == 'warn') {
      foreach ($modules as $msg) {
        drupal_set_message($msg, 'error');
      }
      continue;
    }

    foreach ($modules as $module => $tables) {
      $counts[$state] += count($tables);
      switch ($state) {
        case 'same':
        case 'missing':
          $data[$state] .= theme('item_list', array_keys($tables), $module);
          break;

        case 'different':
          $items = array();
          foreach ($tables as $name => $stuff) {
            $items[] = "<h4>$name</h4>".theme('item_list', 
              array_merge($tables[$name]['reasons'], $tables[$name]['notes']));
          }
          
          $form = array();
          $form[$module] = array(
            '#type' => 'fieldset',
            '#title' => t($module),
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
            '#value' => '',
            );
          $form[$module]['content'] = array(
            '#value' => theme('item_list', $items),
            );
          $data[$state] .= drupal_render($form);
          break;
      }
    }
  }
  if (isset($data['extra'])) {
    $data['extra'] = theme('item_list', $data['extra']);
  }

  $form = array();
  $weight = 0;
  foreach ($states as $state => $content) {
    $content = (isset($data[$state]) ? $data[$state] : '');
    $form[$state] = array(
      '#type' => 'fieldset',
      '#title' => t('@state (@count)', 
        array('@state' => $states[$state], '@count' => isset($counts[$state]) ? $counts[$state] : 0)),
      '#description' => t($descs[$state]),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => $weight++,
      '#value' => '',
      );
    $form[$state]['content'] = array(
      '#type' => 'markup',
      '#value' => $content);
  }

  $output = <<<EOT
<p>This page compares the live database as it currently exists against
the combination of all schema information provided by all enabled modules.</p>
EOT;

  $output .= drupal_render($form);
  return $output;
}

function schema_inspect() {
  $schema = drupal_get_schema();
  $inspect = schema_invoke('inspect');
  foreach ($inspect as $name => $table) {
    $module = isset($schema[$name]) ? $schema[$name]['module'] : 'Unknown';
    if (!isset($form[$module])) {
      $form[$module] = array(
        '#type' => 'fieldset',
        '#access' => TRUE,
        '#title' => check_plain($module),
        '#collapsible' => TRUE,
        '#collapsed' => ($module != 'Unknown'),
        '#weight' => ($module == 'Unknown' ? 0 : 1),
        '#value' => '');
    }
    $form[$module][$name] = array(
      '#type' => 'markup',
      '#value' => '<textarea style="width:100%" rows="10">'.check_plain(schema_phpprint_table($name, $table)).'</textarea>');
  }

  $output = <<<EOT
<p>This page shows the live database schema as it currently
exists on this system.  Known tables are grouped by the module that 
defines them; unknown tables are all grouped together.</p>

<p>To implement hook_schema() for a module that has existing tables, copy 
the schema structure for those tables directly into the module's 
hook_schema() and return $schema.</p>
EOT;

  $output .= drupal_render($form);

  return $output;
}

function schema_sql($engine = NULL) {
  $schema = drupal_get_schema(); // schema_invoke_all();
  $sql = '';
    foreach ($schema as $name => $table) {
      if (substr($name, 0, 1) == '#') {
        continue;
      }
      if ($engine) {
        $stmts = call_user_func('schema_'.$engine.'_create_table_sql', $table);
      } else {
        $stmts = db_create_table_sql($table);
      }

      $sql .= implode(";\n", $stmts).";\n\n";
    }
    
  $output = <<<EOT
<p>This page shows the CREATE TABLE statements that the Schema module 
generates for the selected database engine for each table defined by a
module.  It is for debugging purposes.</p>
<textarea style="width:100%" rows="30">$sql</textarea>
EOT;

  return $output;
}

function schema_show() {
  $schema = drupal_get_schema();
  $show = print_r($schema,1);
    
  $output = <<<EOT
<textarea style="width:100%" rows="30">$show</textarea>
EOT;

  return $output;
}

//////////////////////////////////////////////////////////////////////
// Schema query stuff.  EXPERIMENTAL, do not try to use this yet.
//////////////////////////////////////////////////////////////////////

function schema_schema_alter(&$schema) {
  // Compute and store inverted join information so each table knows
  // which other tables join to it.
  foreach ($schema as $t_name => $table) {
      $module = $table['module'];
      foreach ($table['fields'] as $c_name => $col) {
        if (isset($col['join'])) {
          list($to_mod, $to_tab, $to_col) = $col['join'];
          $schema[$to_mod][$to_tab]['join-from'][] = array(
            $to_col, $module, $t_name, $c_name, $col['join-type']);
        }
      }
  }

  // Generate the SQL query for each table.
  foreach ($schema as $t_name => $table) {
      _schema_generate_table($schema, $t_name);
  }

  if (module_exists('node')) {
    $node_types = node_get_types();
    foreach ($node_types as $type) {
      _schema_generate_table($schema, 'node', $type->type);
    }
  }
}

// Generate the SELECT query and associated data to retrieve a
// complete entity from $module's table $t_name.
//
// If $o_type is provided (e.g. "story" if $module is "node")
// eliminate joins to tables that specify which $module types they
// join to and do not include $o_type in the list.  This eliminates
// joins that will never produce any results.  It is currently only
// used for node.
function _schema_generate_table(&$schema, $t_name, $o_type = NULL) {
  $table = $schema[$t_name];

  // We can't build a WHERE clause for a table without a primary key.
  if (!isset($table['primary key'])) {
    return;
  }
  // SELECT each column individually from the primary table so
  // we can access it by name.
  foreach ($table['fields'] as $c_name => $col) {
    $sel_as = "${t_name}_${c_name}";
    $selcols[$t_name][] = $sel_as;
    $sels[] = "$t_name.$c_name as $sel_as";
  }
  foreach ($table['primary key'] as $pcol) {
    $primarys[$t_name][] = "${t_name}_${pcol}";
    switch ($table['fields'][$pcol]['type']) {
      case 'int': 
      case 'float':
        $wheres[] = "${t_name}.${pcol}=%d";
        break;
      default:
        $wheres[] = "${t_name}.{$pcol}='%s'";
        break;
    }
  }

  $joins = array();
  if (!isset($schema[$t_name]['join-from'])) {
    $schema[$t_name]['join-from'] = array();
  }

  $join_many = 0;
  foreach ($schema[$t_name]['join-from'] as $join) {
    list($my_col, $to_mod, $to_tab, $to_col, $join_type) = $join;
    $table = $schema[$to_mod][$to_tab];

    if (isset($o_type) && is_array($table['fields'][$to_col][$t_name.'-types'])&&
      array_search($o_type, $table['fields'][$to_col][$t_name.'-types'])
      === FALSE) {
      continue;
    }
    
    // SELECT each column individually from the joined table so
    // we can access it by name.
    foreach ($table['fields'] as $c_name => $col) {
      $sel_as = "${to_tab}_${c_name}";
      $selcols[$to_tab][] = $sel_as;
      $sels[] = "$to_tab.$c_name as $sel_as";
    }

    if (isset($table['primary key'])) {
      foreach ($table['primary key'] as $pcol) {
        $primarys[$to_tab][] = "${to_tab}_${pcol}";
      }
    } else {
      drupal_set_message("Schema: join to $t_name requires a primary key", 'error');
      break;
    }

    // LEFT JOIN to each table.  We need to use LEFT JOIN
    // because only a subset of the tables will have any data
    // for this node.
    $joins[] ="LEFT JOIN {$to_tab} $to_tab ON $t_name.$my_col=$to_tab.$to_col";
    $jointypes[$to_tab] = $join_type;
    if ($join_type == 'many') {
      $join_many++;
    }
  }

  // Execute our rather large assembled query.  Not just for Views anymore!
  $sql = ('SELECT '.implode(",\n\t", $sels)."\nFROM {$t_name} $t_name\n".
	  implode("\n\t", $joins)."\nWHERE ".
	  implode(' AND ', $wheres));
  //dpm($sql);

  if (isset($o_type)) {
    $schema[$t_name]['query-'.$o_type] = $sql;
    $schema[$t_name]['selcols-'.$o_type] = $selcols;
    $schema[$t_name]['primarys-'.$o_type] = $primarys;
  } else {
    $schema[$t_name]['query'] = $sql;
    $schema[$t_name]['selcols'] = $selcols;
    $schema[$t_name]['primarys'] = $primarys;
  }
  if (isset($jointypes)) {
    $schema[$t_name]['jointypes'] = $jointypes;
  }
}

function schema_nodeapi(&$node, $op, $a3, $a4) {
  switch ($op) {
    case 'load':
      if (! isset($node->schema_data)) {
        return schema_node_load($node->nid, $node->type, $node);
      }
      break;

    case 'view':
      // For easy debugging and demonstration, display the data we
      // loaded in the node body.  This is temporary, of course.
      $node->content['schema_data'] = array(
        '#title' => 'schema_data',
        '#value' => '<p><b>data loaded by schema in one query</b></p><textarea style="width:100%" rows="30">'.print_r($node->schema_data,1).'</textarea>',
        '#weight' => 99);
      
      break;
  }
}

function schema_node_load($nid, $ntype = NULL, $node = NULL) {
  $schema = schema_invoke_all();

  if (isset($ntype) && 
    isset($schema['system']['node']['query-'.$ntype])) {
    $sql = $schema['system']['node']['query-'.$ntype];
    $selcols = $schema['system']['node']['selcols-'.$ntype];
    $primarys = $schema['system']['node']['primarys-'.$ntype];
  } else {
    $sql = $schema['system']['node']['query'];
    $selcols = $schema['system']['node']['selcols'];
    $primarys = $schema['system']['node']['primarys'];
  }
  $jointypes = $schema['system']['node']['jointypes'];

  //dpm($sql);
  $q = db_query($sql, $nid);

  // Each row of the results will have values from one or more
  // tables.  We saved the list of columns selected from each
  // table above.  For each row, if any of the columns from a
  // particular table are non-NULL, save all of that table's
  // columns for this row.  If all of the columns are NULL, we are
  // seeing LEFT JOIN artifact, so we skip it.
  //
  // The nature of this query is that we get a lot of duplicated
  // data and we have to be sure to ignore all but one copy of
  // each unique result.  For one-joins, it is easy: after we get
  // results for that table we just stop looking for them.  For
  // many-joins, we keep track of the primary keys we've seen from
  // that table and only save a row's data if we haven't seen that
  // primary key yet (by definition, primary keys are unique).
  //
  // Save all the data in $node->schema_data, an array mapping
  // table names to an array of result rows.
  while ($r = db_fetch_array($q)) {
    foreach ($selcols as $table => $cols) {
      $vals = array();
      $got_val = FALSE;
      foreach ($cols as $sel_as) {
        $vals[$sel_as] = $r[$sel_as];
        $got_val = $got_val || !is_null($r[$sel_as]);
      }
      if ($got_val) {
        $keys = $primarys[$table];
        $keyvals = implode('::', array_intersect_key($vals, array_flip($primarys[$table])));
        if (isset($schema_data[$table][$keyvals])) {
          continue;
        }
        $tlen = strlen($table)+1;
        foreach ($vals as $key=>$val) {
          $schema_data[$table][$keyvals][substr($key, $tlen)] = $val;
        }
            
        if ($jointypes[$table] == 'one') {
          // ignore any repeated data from this table
          unset($selcols[$table]);
        }
      }
    }
  }

  // If we're being called by node_load, assemble the node object it
  // expects.  XXX This is a kludge.  users and node both define column
  // 'status', but we want node's, so we list userse first.  This is
  // just a temporary hack anyway; if node_load() wants to use Schema
  // it should just use schema_data directly or assemble the fields of
  // the $node object itself.
  if (is_null($node)) {
    $node = array_merge(
      $schema_data['users'][$schema_data['node'][$nid]['uid']],
      $schema_data['node_revisions'][$schema_data['node'][$nid]['vid']],
      $schema_data['node'][$nid]
      );
    $node = (object) $node;
  }

  $node->schema_data = $schema_data;
  return $node;
}
  
?>
